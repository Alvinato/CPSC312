{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf130
{\fonttbl\f0\fnil\fcharset0 HelveticaNeue;\f1\froman\fcharset0 Times-Roman;}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl358\partightenfactor0

\f0\fs28 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 1.) The domain describes 8 planets in our solar system.  The planets are mainly divided by the condition of either outer or inner planets - 4 are inner and 4 are outer. Then each planet is defined by colour, size, atmosphere, relative distance to the sun and other unique attributes.\
\
Initially it was difficult to understand the syntax which the given parsers read the rules.  Further down the line it was also difficult to categorize the different planets, to find unique and shared characteristics.\
\
\
\
2.)   The code behaves exactly like the example provided in the question and the bonus part was completed as the interpreters quit command has been implemented.\
\
The interpreter is prompted with the keyword \'91main\'92 this prompts a user message which provides all available commands - load, solve, help, list, assert, goal, prove and quit. \
\
The load function is initialized when the user types \'91load.\'92,  a user message will appear asking for the user to insert the filename in double quotes.  The user can insert a file name, say for example \'93planets.kb\'94, once inserted all rules that were understood will be printed out. \
\
Once loaded the solve function can be called through typing \'93solve\'94.  The program will then ask a series of questions and find the domain that is trying to be found. \
\
The bonus was completed as typing the quit command will exit the interpreter.\
\
\
\
3.)  the goal is able to be specified once you have entered the interpreter by typing \'91main.\'92 then \'91goal.\'92  the interpreter will prompt the message \'91enter a new goal, followed by a period\'92.\
\
 After this the goal can be typed and submitted with a period at the end.  All examples given in the question will run properly.  \
\
To take a look at the output that is asserted to db use the list function in the interpreter, the goal will be the last one printed. \
\
The logic begins at process3 where it is invoked at line 112.  The predicate accepts the sentence that was just inputted by the user. \
\
Within the predicate the sentence that was inputted by the user is parsed with goal_sentence/4 predicate.  The predicate variables N and V that are outputted are used in add_list/4 which form the correct attribute syntax for the assertz/ function on line 535.  Furthermore this predicate deletes all current goals before asserting the new one that was just created by the user on line 531, with the forall predicate.\
\
The bonus was completed in this portion as well as when the user types \'91what the heck is that\'92 the default \'91what is it\'92 top goal is set.\
\
4.) This question was explained as part of question 3. \
\
\
5.)   The assert function starts on line 121 in the predicate process2.  The predicate calls the predicate \'91process\'92 on line 476, an existing predicate prewritten in the assignment.  The predicate given then parses the rule or fact that is inputted by the user and asserts it to the database. \
\
\
\
\
reflection questions: \
\
1.) i am impressed with how dense prolog code is, that is how much every line of prolog code equates to many lines in other languages that i have learned.  Especially with DCG syntax.  \
As impressive as I found this dense feature, its downside was that it was a very difficult language to learn and read, especially when the code base began to become large.  Furthermore i found the language was very strict with syntax.\
\
2.) I thought the codebase was well documented, however the frustrating part of it was the sheer magnitude of text that came along with these tools.  Although the descriptions and functions of predicates were well done, examples would have been incredibly beneficial, outlining how the predicates can be used.  Furthermore line numbers to coinciding predicate calls would have been also helpful as with such a large file it was difficult keeping my place within the logic.\
\
\
3.) I could apply this natural language understanding to search engine development, language processing for text documents, languages translators, and possibly even developing new programming languages that take away strict syntactic rules \'97 make it more intuitive, as if you were writing and explaining it to a person.\
\
4.) We could have had better communication among team members on which parts each member was going to focus on.  The result was overlapping work between team members and failure to complete bonus questions. \
\
5.) 50 \
\
\
Wesley Lee 5/5\
Wayne Ku 5/5 \
Alvin Chan 5/5\
\
\
	\
\pard\pardeftab720\sl280\partightenfactor0

\f1\fs24 \cf2 \cb1 \
\pard\pardeftab720\sl358\partightenfactor0

\f0\fs28 \cf2 \cb3 \
\
}